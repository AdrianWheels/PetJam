# üìã **PLAN DE IMPLEMENTACI√ìN: MEJORAS MINIJUEGOS**
### *Priorizaci√≥n y Fases de Desarrollo*

**Fecha:** 24 de Octubre, 2025  
**Basado en:** `INFORME_MINIJUEGOS_FORJA.md`  
**Estado:** Propuesta para revisi√≥n

---

## üéØ **CRITERIOS DE PRIORIZACI√ìN**

Cada mejora se eval√∫a seg√∫n:

| Criterio | Peso | Descripci√≥n |
|----------|------|-------------|
| **Impacto en jugabilidad** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ¬øMejora significativamente la experiencia? |
| **Riesgo de ruptura** | ‚≠ê‚≠ê‚≠ê‚≠ê | ¬øPuede romper sistemas existentes? |
| **Complejidad t√©cnica** | ‚≠ê‚≠ê‚≠ê | ¬øCu√°nto tiempo/esfuerzo requiere? |
| **Dependencias** | ‚≠ê‚≠ê | ¬øRequiere otros sistemas primero? |

**Escala de riesgo:**
- üü¢ **BAJO:** Cambios aislados, f√°cil rollback
- üü° **MEDIO:** Afecta m√∫ltiples archivos, requiere pruebas
- üî¥ **ALTO:** Cambios estructurales, puede romper saves/l√≥gica existente

---

## üìä **AN√ÅLISIS DE PROPUESTAS**

### **MEJORAS GENERALES**

#### ‚úÖ **1. Presets por tier + "difficulty budget"**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (facilita dise√±o de contenido enormemente)
- **Riesgo:** üü¢ BAJO (sistema nuevo, no toca c√≥digo existente)
- **Complejidad:** Media (crear sistema de presets y funciones de mapeo)
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# res://scripts/data/MinigameDifficultyPreset.gd
class_name MinigameDifficultyPreset extends Resource

@export var tier: int = 1  # 1=Com√∫n, 2=Raro, 3=Legendario
@export var difficulty_budget: float = 50.0  # 0-100
@export var shares: Dictionary = {
    "temp": 0.25,
    "hammer": 0.25,
    "sew": 0.25,
    "quench": 0.25
}

func get_temp_config() -> Dictionary:
    var local_diff = difficulty_budget * shares.temp
    return {
        "hardness": remap(local_diff, 0, 100, 0.2, 0.9),
        "precision": remap(local_diff, 0, 100, 0.6, 0.1),
        "temp_window_base": remap(local_diff, 0, 100, 100, 60)
    }
# ... similar para hammer, sew, quench
```

---

#### ‚úÖ **2. Normalizaci√≥n 0-100 + fusi√≥n robusta**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê (evita desbalance entre minijuegos)
- **Riesgo:** üü° MEDIO (cambia scoring, puede afectar balance existente)
- **Complejidad:** Baja (ya existe `max_score` en TrialResult)
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# En CraftingManager o sistema de fusi√≥n
func fuse_trials(results: Array[TrialResult], weights: Dictionary) -> float:
    var normalized_scores := []
    var total_weight := 0.0
    
    for result in results:
        var norm_score = (result.score / result.max_score) * 100.0
        normalized_scores.append(norm_score)
        total_weight += weights.get(result.minigame_id, 1.0)
    
    # Media geom√©trica ponderada para evitar hard-carry
    var product := 1.0
    for i in range(normalized_scores.size()):
        var weight = weights.get(results[i].minigame_id, 1.0) / total_weight
        product *= pow(normalized_scores[i] / 100.0, weight)
    
    return product * 100.0
```

---

#### ‚ö†Ô∏è **3. Telemetr√≠a, seeds y replays**
- **Impacto:** ‚≠ê‚≠ê‚≠ê (√∫til para debugging y an√°lisis)
- **Riesgo:** üü¢ BAJO (TelemetryManager ya existe)
- **Complejidad:** Media (a√±adir campos a logs)
- **Fase sugerida:** **FASE 2** üîÑ

**Implementaci√≥n:**
```gdscript
# A√±adir a cada minijuego en start_trial()
func start_trial(config: TrialConfig) -> void:
    super.start_trial(config)
    var seed_value = randi()
    seed(seed_value)
    TelemetryManager.log_event("minigame_start", {
        "minigame": config.minigame_id,
        "blueprint": config.blueprint_id,
        "seed": seed_value,
        "timestamp": Time.get_ticks_msec(),
        "parameters": config.parameters.duplicate()
    })
```

---

#### ‚úÖ **4. Guardarra√≠les de viabilidad**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (previene configuraciones frustrantes)
- **Riesgo:** üü¢ BAJO (solo a√±ade clamps)
- **Complejidad:** Baja (revisar rangos en cada minijuego)
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# A√±adir constantes de seguridad en cada minijuego
const SAFETY_LIMITS = {
    "temp": {"min_zone_px": 30, "max_freq_hz": 1.6},
    "hammer": {"min_bpm": 60, "max_bpm": 200, "min_window_ms": 30},
    "sew": {"max_speed": 1.8, "min_window_px": 2},
    "quench": {"min_window_c": 12, "max_k": 0.95}
}

func apply_blueprint(bp):
    # Ejemplo en TempMinigame
    var hardness = clamp(bp.hardness, 0, 0.875)  # Garantiza zona ‚â•30px
    var temp_window = max(bp.temp_window_base * (1 - 0.6*hardness), 30)
```

---

### **NUEVAS MEC√ÅNICAS**

#### üöÄ **5. Coser: C√≠rculo m√≥vil**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (aumenta skill ceiling significativamente)
- **Riesgo:** üü° MEDIO (cambia mec√°nica core de Coser)
- **Complejidad:** Media (a√±adir movimiento al anillo)
- **Fase sugerida:** **FASE 2** üîÑ

**Implementaci√≥n:**
```gdscript
# En SewMinigame.gd, a√±adir movimiento aleatorio
var target_offset := Vector2.ZERO
var offset_speed := 80.0  # px/s

func _schedule_next_note():
    super._schedule_next_note()
    # Nuevo target aleatorio dentro de bounds
    var max_offset = 60 * scale_factor
    target_offset = Vector2(
        randf_range(-max_offset, max_offset),
        randf_range(-max_offset, max_offset)
    )

func _process(delta):
    super._process(delta)
    if running and note_active:
        # Lerp suave hacia target
        var center = Vector2(cx, cy)
        center = center.lerp(center + target_offset, delta * 2.0)
        # Actualizar posici√≥n del anillo en _draw()
```

---

### **BALANCE Y TUNING**

#### ‚úÖ **6. Martillo: Ventanas dependientes de BPM**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê (mejora fairness en BPMs extremos)
- **Riesgo:** üü¢ BAJO (ajuste de f√≥rmula existente)
- **Complejidad:** Baja (cambiar c√°lculo de ventanas)
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# En HammerMinigame.gd
func make_windows(precision):
    var p = clamp(precision, 0, 1)
    var bpm = _pending_blueprint.get("tempoBPM", DEFAULT_BPM)
    
    # Ventanas m√°s generosas en BPMs altos
    var bpm_scaling = lerp(1.0, 1.25, clamp((bpm - 140) / 60.0, 0, 1))
    
    return {
        "perfect": WINDOWS_BASE.perfect,  # No escala
        "bien": WINDOWS_BASE.bien * lerp(1.2, 0.7, p) * bpm_scaling,
        "regular": WINDOWS_BASE.regular * lerp(1.2, 0.7, p) * bpm_scaling
    }
```

---

#### ‚úÖ **7. Coser: Ventanas por √°rea visual + pre-freeze**
- **Impacto:** ‚≠ê‚≠ê‚≠ê (mejora UX en velocidades altas)
- **Riesgo:** üü¢ BAJO (ajuste de f√≥rmula)
- **Complejidad:** Baja
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# En SewMinigame.gd
func compute_windows(precision):
    var p = clamp(precision, 0, 1)
    var radius_factor = sqrt(r / ring_r) if r > 0 else 1.0
    
    # Pre-freeze cerca del anillo
    var freeze_threshold = ring_r + 15
    if r <= freeze_threshold and bp.stitchSpeed >= 1.5:
        speed *= 0.3  # 70% m√°s lento en √∫ltimos px
    
    return {
        "perfect": 3 * (1 + 0.5 * p) * radius_factor,
        "bien": 8 * (1 + 0.35 * p) * radius_factor,
        "regular": 14 * (1 + 0.20 * p) * radius_factor
    }
```

---

#### ‚ö†Ô∏è **8. Temple: Ventana en tiempo + ajuste catalizador**
- **Impacto:** ‚≠ê‚≠ê‚≠ê (a√±ade dimensi√≥n temporal)
- **Riesgo:** üü° MEDIO (cambia mec√°nica, requiere ajuste de balance)
- **Complejidad:** Media
- **Fase sugerida:** **FASE 2** üîÑ

**Implementaci√≥n:**
```gdscript
# En QuenchMinigame.gd
func eval_drop(temp, time_sec):
    var win = effective_window()
    var delta_temp = abs(temp - win.center)
    
    # Ventana temporal basada en k
    var k = bp.k
    var window_time_ms = clamp(0.8 * (1.0 / k) * 1000, 120, 900)
    var optimal_time = calculate_optimal_drop_time()
    var delta_time = abs(time_sec * 1000 - optimal_time)
    
    # Combinaci√≥n: debe estar bien en AMBAS dimensiones
    var temp_ok = delta_temp <= (win.half if not bp.catalyst else win.half * 1.2)
    var time_ok = delta_time <= window_time_ms
    
    if temp_ok and time_ok:
        # L√≥gica existente...
        if bp.catalyst:
            score = min(100, score * 0.92)  # -8% multiplier por facilidad
```

---

#### ‚úÖ **9. Anti-spam global**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê (previene cheese y mejora feel)
- **Riesgo:** üü¢ BAJO (l√≥gica defensiva)
- **Complejidad:** Baja
- **Fase sugerida:** **FASE 1** ‚ú®

**Implementaci√≥n:**
```gdscript
# En MinigameBase.gd (clase base)
var _last_input_time := 0
var _input_burst_count := 0
var _burst_window_ms := 500
const INPUT_COOLDOWN_MS = 150

func _input(event):
    if not (event is InputEventMouseButton or event is InputEventKey):
        return
    if not event.pressed:
        return
        
    var now = Time.get_ticks_msec()
    
    # Anti-spam: cooldown m√≠nimo
    if now - _last_input_time < INPUT_COOLDOWN_MS:
        return
    
    # Detecci√≥n de r√°faga
    if now - _last_input_time < _burst_window_ms:
        _input_burst_count += 1
        if _input_burst_count > 3:
            # Penalizaci√≥n temporal: ventanas -10%
            apply_spam_penalty()
    else:
        _input_burst_count = 0
    
    _last_input_time = now
    _on_valid_input(event)
```

---

### **UX/UI**

#### ‚úÖ **10. Feedback multimodal**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (JUICE fundamental)
- **Riesgo:** üü¢ BAJO (AudioManager ya existe)
- **Complejidad:** Media (requiere assets de audio)
- **Fase sugerida:** **FASE 2** üîÑ

**Implementaci√≥n:**
```gdscript
# Crear res://scripts/ui/MinigameFeedback.gd
class_name MinigameFeedback extends Node

const SOUNDS = {
    "Perfect": preload("res://art/sounds/sfx_perfect.wav"),
    "Bien": preload("res://art/sounds/sfx_good.wav"),
    "Regular": preload("res://art/sounds/sfx_ok.wav"),
    "Miss": preload("res://art/sounds/sfx_miss.wav")
}

func play_quality_feedback(quality: String, position: Vector2):
    # Audio
    if SOUNDS.has(quality):
        AudioManager.play_sfx(SOUNDS[quality], {"pitch": randf_range(0.97, 1.03)})
    
    # Visual: pulso en centro
    var pulse = create_pulse_effect(position, quality)
    get_tree().current_scene.add_child(pulse)
    
    # H√°ptico (si disponible)
    if Input.is_joy_known(0):
        Input.start_joy_vibration(0, 0.3, 0.0, 0.1)
```

---

### **INTEGRACI√ìN CON OTROS SISTEMAS**

#### ‚ö†Ô∏è **11. Calidad ‚Üí Stats del √≠tem**
- **Impacto:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (core gameplay loop)
- **Riesgo:** üî¥ ALTO (requiere sistema de items completo)
- **Complejidad:** Alta (integraci√≥n con equipamiento y combate)
- **Fase sugerida:** **FASE 3** üîÆ

**Requiere:**
- Sistema de items funcional
- Stats de Hero implementados
- CraftingManager conectado con inventario

---

#### ‚ö†Ô∏è **12. Maestr√≠as por minijuego**
- **Impacto:** ‚≠ê‚≠ê‚≠ê (progresi√≥n meta)
- **Riesgo:** üü° MEDIO (nuevo sistema de progresi√≥n)
- **Complejidad:** Alta (persistencia, unlock trees)
- **Fase sugerida:** **FASE 3** üîÆ

---

#### ‚úÖ **13. Logros internos**
- **Impacto:** ‚≠ê‚≠ê‚≠ê (engagement y replayabilidad)
- **Riesgo:** üü¢ BAJO (sistema independiente)
- **Complejidad:** Media (tracking + UI)
- **Fase sugerida:** **FASE 2** üîÑ

---

## üìÖ **ROADMAP DE FASES**

### **FASE 1: Fundamentos S√≥lidos** ‚ú® (Prioridad ALTA)
**Duraci√≥n estimada:** 2-3 horas  
**Objetivo:** Mejorar robustez y balance sin romper nada

- ‚úÖ Guardarra√≠les de viabilidad (clamps de seguridad)
- ‚úÖ Anti-spam global (input cooldown + burst detection)
- ‚úÖ Normalizaci√≥n 0-100 + fusi√≥n robusta
- ‚úÖ Presets por tier + difficulty budget
- ‚úÖ Martillo: ventanas dependientes de BPM
- ‚úÖ Coser: ventanas por √°rea visual + pre-freeze

**Riesgo total:** üü¢ BAJO  
**Archivos afectados:**
- `MinigameBase.gd` (anti-spam)
- `TempMinigame.gd` (clamps)
- `HammerMinigame.gd` (ventanas BPM)
- `SewMinigame.gd` (ventanas √°rea + pre-freeze)
- `MinigameDifficultyPreset.gd` (NUEVO)
- `CraftingManager.gd` (fusi√≥n robusta)

---

### **FASE 2: Experiencia y Polish** üîÑ (Prioridad MEDIA)
**Duraci√≥n estimada:** 3-4 horas  
**Objetivo:** Mejorar feel y engagement

- üé® Feedback multimodal (sonidos + visuales)
- üéØ Coser: c√≠rculo m√≥vil
- üìä Telemetr√≠a mejorada (seeds + replays)
- ‚è±Ô∏è Temple: ventana temporal + ajuste catalizador
- üèÜ Logros internos b√°sicos

**Riesgo total:** üü° MEDIO  
**Requiere:** Assets de audio (6-8 SFX cortos)

---

### **FASE 3: Integraci√≥n Profunda** üîÆ (Prioridad BAJA)
**Duraci√≥n estimada:** 6+ horas  
**Objetivo:** Conectar con sistemas de progresi√≥n

- ‚öîÔ∏è Calidad ‚Üí Stats del √≠tem
- üìà Maestr√≠as por minijuego
- üíæ Sistema de persistencia robusto

**Riesgo total:** üî¥ ALTO  
**Requiere:** Sistemas de combate e inventario completos

---

## ‚úÖ **RECOMENDACI√ìN INMEDIATA**

### **Implementar FASE 1 completa**

**Razones:**
1. **Riesgo m√≠nimo:** Solo mejoras defensivas y ajustes de balance
2. **Impacto alto:** Mejora sustancialmente la experiencia sin romper nada
3. **Base s√≥lida:** Prepara arquitectura para Fase 2 y 3
4. **Tiempo razonable:** 2-3 horas para implementar + 30 min de testing

**Orden de implementaci√≥n sugerido:**
```
1. Guardarra√≠les (15 min) ‚Üí Testing inmediato
2. Anti-spam (30 min) ‚Üí Testing
3. Presets + difficulty budget (60 min) ‚Üí Testing con varios tiers
4. Normalizaci√≥n + fusi√≥n (30 min) ‚Üí Testing
5. Ajustes de ventanas BPM/√°rea (30 min) ‚Üí Testing final
```

---

## üß™ **TESTING CHECKLIST (FASE 1)**

Antes de mergear, verificar:

- [ ] **Temperatura:** Hardness=0.9 genera zona ‚â•30px
- [ ] **Martillo:** BPM=180 tiene ventanas razonables (‚â•50ms)
- [ ] **Coser:** StitchSpeed=1.8 tiene pre-freeze activo
- [ ] **Temple:** Ventanas nunca <12¬∞C
- [ ] **Anti-spam:** Spam de clicks no registra m√∫ltiples hits
- [ ] **Presets:** Tier 1/2/3 generan dificultades progresivas
- [ ] **Fusi√≥n:** 2 Perfect + 1 Miss no da score inflado
- [ ] **Sin regresiones:** Partidas existentes siguen funcionando

---

## üìù **NOTAS FINALES**

### **Lo que NO hacer ahora:**
- ‚ùå No tocar sistema de combate/hero
- ‚ùå No cambiar formato de guardado
- ‚ùå No a√±adir dependencias externas
- ‚ùå No refactorizar nombres de archivos existentes

### **Ventanas de oportunidad:**
- ‚ú® Fase 1 se puede implementar en una tarde
- ‚ú® Cada mejora es independiente ‚Üí rollback f√°cil
- ‚ú® Mejoras preparatorias para sistemas futuros

---

*¬øProceder con Fase 1? Responde "S√≠, implementar Fase 1" para comenzar.*
